<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.0.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-前端项目中常见的异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/16/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  	<time datetime="2020-04-16T06:17:37.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/16/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
        前端项目中常见的异常处理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​     在平常的前端项目开发中，稍有不小心就会遇到报错等异常问题，有时候要经过很多次的反复调试才能找到bug所在，实在很棘手，这里总结了一些常见的异常问题，方便以后提高解决问题的效率。首先我们先探讨一些问题：</p>
<h3 id="一、为什么要处理异常？"><a href="#一、为什么要处理异常？" class="headerlink" title="一、为什么要处理异常？"></a>一、为什么要处理异常？</h3><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p>
<ol>
<li>增强用户体验；</li>
<li>远程定位问题；</li>
<li>未雨绸缪，及早发现问题；</li>
<li>无法复线问题，尤其是移动端，机型，系统都是问题；</li>
<li>完善的前端方案，前端监控系统；</li>
</ol>
<p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<h3 id="二、需要处理哪些异常？"><a href="#二、需要处理哪些异常？" class="headerlink" title="二、需要处理哪些异常？"></a>二、需要处理哪些异常？</h3><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p>
<ul>
<li><p>JS 语法错误、代码异常</p>
</li>
<li><p>AJAX 请求异常</p>
</li>
<li><p>静态资源加载异常</p>
</li>
<li><p>Promise 异常</p>
</li>
<li><p>Iframe 异常</p>
</li>
<li><p>跨域 Script error</p>
</li>
<li><p>崩溃和卡顿</p>
<h3 id="三、Try-Catch-的误区"><a href="#三、Try-Catch-的误区" class="headerlink" title="三、Try-Catch 的误区"></a>三、Try-Catch 的误区</h3><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</p>
<ol>
<li>同步运行时错误：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name &#x3D; &#39;jartto&#39;;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&#39;捕获到异常：&#39;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常：ReferenceError: nam is not defined</span><br><span class="line">    at &lt;anonymous&gt;:3:15</span><br></pre></td></tr></table></figure>

<p>2.不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name &#x3D; &#39;jartto;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&#39;捕获到异常：&#39;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</span><br></pre></td></tr></table></figure>

<p>3.异步错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    undefined.map(v &#x3D;&gt; v);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&#39;捕获到异常：&#39;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &#39;map&#39; of undefined</span><br><span class="line">    at setTimeout (&lt;anonymous&gt;:3:11)</span><br></pre></td></tr></table></figure>

<p>然而并没有捕获到异常。</p>
<h3 id="四、window-onerror"><a href="#四、window-onerror" class="headerlink" title="四、window.onerror"></a>四、window.onerror</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @param &#123;String&#125;  message    错误信息</span><br><span class="line">* @param &#123;String&#125;  source    出错文件</span><br><span class="line">* @param &#123;Number&#125;  lineno    行号</span><br><span class="line">* @param &#123;Number&#125;  colno    列号</span><br><span class="line">* @param &#123;Object&#125;  error  Error对象（对象）</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">   console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先试试同步运行时错误</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">&#x2F;&#x2F; message：错误信息（字符串）。</span><br><span class="line">&#x2F;&#x2F; source：发生错误的脚本URL（字符串）</span><br><span class="line">&#x2F;&#x2F; lineno：发生错误的行号（数字）</span><br><span class="line">&#x2F;&#x2F; colno：发生错误的列号（数字）</span><br><span class="line">&#x2F;&#x2F; error：Error对象（对象）</span><br><span class="line">console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Jartto;</span><br></pre></td></tr></table></figure>

<p>查看结果发现我们捕获到了异常：</p>
<p>2.再试试语法错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">let name &#x3D; &#39;Jartto</span><br></pre></td></tr></table></figure>

<p>控制台打印出了这样的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure>

<p>3.最后试试异步运行时错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    Jartto;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常：&#123;message: &quot;Uncaught ReferenceError: Jartto is not defined&quot;, source: &quot;http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;&quot;, lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined</span><br><span class="line">    at setTimeout (http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;:36:5)&#125;</span><br></pre></td></tr></table></figure>

<p>4.再试试网络请求异常的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;.&#x2F;jartto.png&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</code></strong></p>
<p>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    Jartto;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台就不会再有这样的错误了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: Jartto is not defined</span><br><span class="line">    at setTimeout ((index):36)</span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li>
<li>onerror 无法捕获语法错误；</li>
</ul>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<h3 id="五、window-addEventListener"><a href="#五、window-addEventListener" class="headerlink" title="五、window.addEventListener"></a>五、window.addEventListener</h3><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的window.addEventListener 捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scritp&gt;</span><br><span class="line">window.addEventListener(&#39;error&#39;, (error) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;捕获到异常：&#39;, error);</span><br><span class="line">&#125;, true)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;.&#x2F;jartto.png&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>此时控制台会输出“捕获到异常”的结果。</p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li>
<li>需要注意避免 addEventListener 重复监听。</li>
</ul>
<h3 id="六、Promise-Catch"><a href="#六、Promise-Catch" class="headerlink" title="六、Promise Catch"></a>六、Promise Catch</h3><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。</p>
<p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p>
<p>解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>尝试一下下面的方法，并查看输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(&#39;捕获到异常：&#39;, e);</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br><span class="line">Promise.reject(&#39;promise error&#39;);</span><br></pre></td></tr></table></figure>

<p>那如果对 Promise 不进行 catch 呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(&#39;捕获到异常：&#39;, e);</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  reject(&#39;jartto: promise error&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>事实证明，也是会被正常捕获到的。</p>
<p>所以，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。</p>
<p>补充一点：如果去掉控制台的异常显示，需要加上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure>

<h3 id="七、VUE-errorHandler"><a href="#七、VUE-errorHandler" class="headerlink" title="七、VUE errorHandler"></a>七、VUE errorHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler &#x3D; (err, vm, info) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;通过vue errorHandler捕获的错误&#39;);</span><br><span class="line">  console.error(err);</span><br><span class="line">  console.error(vm);</span><br><span class="line">  console.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、iframe-异常"><a href="#八、iframe-异常" class="headerlink" title="八、iframe 异常"></a>八、iframe 异常</h3><p>对于 iframe 的异常捕获，我们还得借力 window.onerror：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&#39;捕获到异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的例子可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src&#x3D;&quot;.&#x2F;iframe.html&quot; frameborder&#x3D;&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.frames[0].onerror &#x3D; function (message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&#39;捕获到 iframe 异常：&#39;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="九、Script-error"><a href="#九、Script-error" class="headerlink" title="九、Script error"></a>九、Script error</h3><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p>
<p>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;jartto.wang&#x2F;main.js&quot; crossorigin&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>或者动态去添加 js 脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">script.crossOrigin &#x3D; &#39;anonymous&#39;;</span><br><span class="line">script.src &#x3D; url;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p>
<p>此外，我们也可以试试这个-解决 Script Error 的另类思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const originAddEventListener &#x3D; EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener &#x3D; function (type, listener, options) &#123;</span><br><span class="line">  const wrappedListener &#x3D; function (...args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return listener.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (err) &#123;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单解释一下：</p>
<p>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(() &#x3D;&gt; &#123;</span><br><span class="line">   const originAddEventListener &#x3D; EventTarget.prototype.addEventListener;</span><br><span class="line">   EventTarget.prototype.addEventListener &#x3D; function (type, listener, options) &#123;</span><br><span class="line">+    &#x2F;&#x2F; 捕获添加事件时的堆栈</span><br><span class="line">+    const addStack &#x3D; new Error(&#96;Event ($&#123;type&#125;)&#96;).stack;</span><br><span class="line">     const wrappedListener &#x3D; function (...args) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         return listener.apply(this, args);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (err) &#123;</span><br><span class="line">+        &#x2F;&#x2F; 异常发生时，扩展堆栈</span><br><span class="line">+        err.stack +&#x3D; &#39;\n&#39; + addStack;</span><br><span class="line">         throw err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="十、崩溃和卡顿"><a href="#十、崩溃和卡顿" class="headerlink" title="十、崩溃和卡顿"></a>十、崩溃和卡顿</h3><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p>
<p>崩溃和卡顿也是不可忽视的，也许会导致用户流失。</p>
<ol>
<li>利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;load&#39;, function () &#123;</span><br><span class="line">    sessionStorage.setItem(&#39;good_exit&#39;, &#39;pending&#39;);</span><br><span class="line">    setInterval(function () &#123;</span><br><span class="line">        sessionStorage.setItem(&#39;time_before_crash&#39;, new Date().toString());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  window.addEventListener(&#39;beforeunload&#39;, function () &#123;</span><br><span class="line">    sessionStorage.setItem(&#39;good_exit&#39;, &#39;true&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if(sessionStorage.getItem(&#39;good_exit&#39;) &amp;&amp;</span><br><span class="line">    sessionStorage.getItem(&#39;good_exit&#39;) !&#x3D;&#x3D; &#39;true&#39;) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        insert crash logging code here</span><br><span class="line">    *&#x2F;</span><br><span class="line">    alert(&#39;Hey, welcome back from your crash, looks like you crashed on: &#39; + sessionStorage.getItem(&#39;time_before_crash&#39;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>2.基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：</p>
<p>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p>
<h3 id="十一、错误上报"><a href="#十一、错误上报" class="headerlink" title="十一、错误上报"></a>十一、错误上报</h3><p>1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p>
<p>2.动态创建 img 标签的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function report(error) &#123;</span><br><span class="line">  let reportUrl &#x3D; &#39;http:&#x2F;&#x2F;jartto.wang&#x2F;report&#39;;</span><br><span class="line">  new Image().src &#x3D; &#96;$&#123;reportUrl&#125;?logs&#x3D;$&#123;error&#125;&#96;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际操作中，如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reporter.send &#x3D; function(data) &#123;</span><br><span class="line">  &#x2F;&#x2F; 只采集 30%</span><br><span class="line">  if(Math.random() &lt; 0.3) &#123;</span><br><span class="line">    send(data)      &#x2F;&#x2F; 上报错误信息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p>
<h3 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h3><p>所以，如何处理异常呢？可以通过以下这些解决办法，采用组合方案，分类型的去捕获异常：</p>
<ol>
<li>可疑区域增加 Try-Catch</li>
<li>全局监控 JS 异常 window.onerror</li>
<li>全局监控静态资源异常 window.addEventListener</li>
<li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li>
<li>VUE errorHandler 和 React componentDidCatch</li>
<li>监控网页崩溃：window 对象的 load 和 beforeunload</li>
<li>跨域 crossOrigin 解决</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-关于http请求中的Content-Type属性的基础理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/06/%E5%85%B3%E4%BA%8Ehttp%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84Content-Type%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3/" class="article-date">
  	<time datetime="2020-03-06T07:22:04.000Z" itemprop="datePublished">2020-03-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/06/%E5%85%B3%E4%BA%8Ehttp%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84Content-Type%E5%B1%9E%E6%80%A7%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3/">
        关于http请求中的Content-Type属性的基础理解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1.Content-Type的概念</strong></p>
<p>Internet Media Type(互联网媒体类型)，也叫做MIME类型，使用两部分标识符来确定一个类型。在HTTP协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息，意思就是说，Content-Type是Internet Media Type在HTTP协议中的别称。</p>
<p><strong>2.Content-Type的格式</strong></p>
<p>type/subtype(;parameter)? type</p>
<p>Content-Type的格式可以拆解为三个部分，分别是主类型（type）、子类型（subtype）和参数（parameter）。</p>
<p><strong><em>2.1  主类型（type）</em></strong></p>
<p>主类型可以是任意的字符串，比如text。如果是*号则代表所有类型。</p>
<p><strong><em>2.2  子类型（subtype）</em></strong></p>
<p>子类型可以是任意的字符串，比如html。如果是*号则代表所有类型。</p>
<p><strong><em>2.3   参数（parameter）</em></strong></p>
<p>参数是可选的，可以在Content-Type中加入一些特殊的参数，比如Accept请求头的参数，常见的有用于设置字符编码的charset参数。</p>
<p>Content-Type: text/html;charset:utf-8</p>
<p><strong>3.Content-Type中常见的媒体格式类型</strong></p>
<p><strong><em>3.1  以text开头的媒体格式类型：</em></strong></p>
<p>text/html： HTML格式。</p>
<p>text/plain：纯文本格式。</p>
<p>text/xml： XML格式。</p>
<p><strong><em>3.2  以image开头的媒体格式类型：</em></strong></p>
<p>image/gif：gif图片格式。</p>
<p>image/jpeg：jpg图片格式。</p>
<p>image/png：png图片格式。</p>
<p><strong><em>3.3  以application开头的媒体格式类型：</em></strong></p>
<p>application/xhtml+xml：XHTML格式。</p>
<p>application/xml： XML数据格式。</p>
<p>application/atom+xml：Atom XML聚合格式 。</p>
<p>application/json： JSON数据格式。</p>
<p>application/pdf：pdf格式 。</p>
<p>application/msword： Word文档格式。</p>
<p>application/octet-stream： 二进制流数据（如常见的文件下载）。</p>
<p>application/x-www-form-urlencoded： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。</p>
<p>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式。</p>
<p><strong>4.Spring MVC中关于Content-Type类型信息的使用</strong></p>
<p>在Spring MVC中，主要就是使用@RequestMapping注解来处理请求：</p>
<p>@Target({ElementType.METHOD, ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Mapping<br>public @interface RequestMapping {<br>    String[] value() default {};<br>    RequestMethod[] method() default {};<br>    String[] params() default {};<br>    String[] headers() default {};<br>    String[] consumes() default {};<br>    String[] produces() default {};<br>}</p>
<p>参数解析如下：</p>
<p>value：指定请求的实际地址， 比如/yanggb/info之类的请求路由。</p>
<p>method： 指定请求的method类型， 比如GET、POST、PUT、DELETE等。</p>
<p>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json、text/html;等。</p>
<p>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。</p>
<p>params：指定request中必须包含某些参数值，才让该方法处理。</p>
<p>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<p>其中，consumes、produces可以使用Content-type中的信息对不需要的信息进行过滤，仅接受需要的数据；headers则可以使用Content-Type中的信息对请求进行过滤和判断。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-npm-run-dev的执行过程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/21/npm-run-dev%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="article-date">
  	<time datetime="2019-12-21T07:54:19.000Z" itemprop="datePublished">2019-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/21/npm-run-dev%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">
        npm run dev的执行过程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>vue开发命令 <code>npm run dev</code> 输入后的执行过程大致有以下几个步骤：</p>
<p><strong>1.npm run dev 是执行配置在package.json中的脚本，比如：</strong></p>
<p>“scripts”: {<br>    “dev”: “webpack-dev-server –inline –progress –config webpack.conf.js”,<br>    “start”: “npm run dev”,<br>    “lint”: “eslint –ext .js,.vue src”,<br>    “build”: “node build/build.js”<br>  },</p>
<p>npm run dev 执行的就是webpack-dev-server –inline ….命令,通过webpack-dev-server开启一个本地调试服务器。</p>
<p><strong>2.在webpack.conf.js文件中找到App的入口文件  ./src/main.js</strong></p>
<p>entry: {<br>   app: ‘./src/main.js’<br>},</p>
<p><strong>3.main.js用到了页面元素#app、用到了路由和根组件App，并根据这些信息创建一个vue实例。</strong></p>
<p>new Vue({<br>     el: ‘#app’,<br>     router,<br>     components: { App },<br>     template: ‘<App/>‘<br>})</p>
<p><strong>4.webpack-dev-server会将main.js中的代码以及所有引用打包成一个bundle.js，然后配置到内存中。</strong></p>
<p><strong>5.webpack.conf.js中配置的HtmlWebpackPlugin会将index.html文件配置到内存，并且将内存中的bundle.js注入到内存中的index.html中。</strong></p>
<p><strong>6.根据webpack.config.js中所配置的devServer的信息，会决定是否自动打开浏览器呈现网页。</strong></p>
<p>devServer: {<br>    open: true, // 自动打开浏览器<br>    port: 3000, // 设置启动时候的运行端口<br>    contentBase: ‘src’, // 指定托管的根目录<br>    hot: true // 启用热更新 的 第1步<br>}</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Javascript中删除数组的几种方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/07/Javascript%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/" class="article-date">
  	<time datetime="2019-12-07T05:56:30.000Z" itemprop="datePublished">2019-12-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/07/Javascript%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">
        Javascript中删除数组的几种方法
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   今天总结7个在JavaScript中删除Array元素的方法，分别是利用length属性、delete关键字、pop()栈方法、shift()队列方法、splice()操作方法、forEach()或filter()迭代方法和prototype原型方法。</p>
<p><strong>1.length属性</strong></p>
<p>length属性不是只读的，可以通过设置这个属性来达到从数组的末尾移除项或添加新项的目的。</p>
<p>var colors = [“red”, “blue”, “grey”]; // 创建一个包含3个字符串的数组 </p>
<p>colors.length = 2;<br>console.log(colors[2]); // undefined</p>
<p><strong>2.delete关键字</strong></p>
<p>JavaScript提供了一个delete关键字用来删除（清除）数组元素。</p>
<p>var colors = [“red”, “blue”, “grey”, “green”]; </p>
<p>delete colors[0]; </p>
<p>console.log(colors);      // [undefined, “blue”, “grey”, “green”]</p>
<p>注意的是，使用delete删除元素之后数组长度不变，只是被删除元素被置为undefined了。</p>
<p><strong>3.pop()栈方法</strong></p>
<p>JavaScript中的Array对象提供了一个pop()栈方法用于弹出并返回数组中的最后一项，某种程度上可以当做删除用。**<em>栈数据结构的访问规则是FILO（First In Last Out，先进后出）**</em>，栈操作在栈顶添加项，从栈顶移除项，使用pop()方法，它能移除数组中的最后一项并返回该项，并且数组的长度减1。</p>
<p>var colors = [“red”, “blue”, “grey”]; </p>
<p>var color = colors.pop(); </p>
<p>console.log(color);       // “grey” </p>
<p>console.log(colors.length);      // 2</p>
<p><strong>4.shift()队列方法</strong></p>
<p>JavaScript中的Array对象提供了一个shift()队列方法用于弹出并返回数组中的第一项，某种程度上也可以当做删除用。**<em>队列数据结构的访问规则是FIFO（First In First Out，先进先出）**</em>，队列在列表的末端添加项，从列表的前端移除项，使用shift()方法，它能够移除数组中的第一个项并返回该项，并且数组的长度减1。</p>
<p>var colors = [“red”, “blue”, “grey”]; </p>
<p>var color = colors.shift(); </p>
<p>console.log(color);      // “red” </p>
<p>console.log(colors.length);     // 2</p>
<p><strong>5.splice()操作方法</strong> </p>
<p>splice()方法用于对数组进行特定的操作。在删除数组元素的时候，它可以删除任意数量的项，只需要指定2个参数：要删除的第一项的位置和要删除的项数。</p>
<p>var colors = [“red”, “blue”, “grey”]; </p>
<p>var color = colors.splice(0, 1); </p>
<p>console.log(color); // “red” </p>
<p>console.log(colors); // [“blue”, “grey”]</p>
<p><strong>6.迭代方法</strong></p>
<p>所谓的迭代方法就是用循环迭代数组元素，发现符合要删除的项则删除。用的最多的地方，可能是当数组中的元素为对象的时候，可以根据对象的某个属性（例如ID）来删除数组元素。</p>
<p>第一种用最常见的ForEach循环来对比元素找到之后将其删除：</p>
<p>var colors = [“red”, “blue”, “grey”];</p>
<p>colors.forEach(function(item, index, arr) {<br>    if(item === “red”) {<br>        arr.splice(index, 1);<br>    }<br>});</p>
<p>第二种用循环中的filter方法：</p>
<p>var colors = [“red”, “blue”, “grey”];</p>
<p>colors = colors.filter(function(item) {<br>    return item != “red”<br>});</p>
<p>console.log(colors);   // [“blue”, “grey”]</p>
<p><strong>7.prototype原型方法</strong></p>
<p>可以通过在Array的原型上添加方法来达到删除的目的。</p>
<p>Array.prototype.remove = function(dx) {<br>　　if(isNaN(dx) || dx &gt; this.length){<br>　　　　return false;<br>　　}</p>
<p>　　for(var i = 0, n = 0; i &lt; this.length; i++) {<br>　　　　if(this[i] != this[dx]) {<br>　　　　　　this[n++] = this[i];<br>　　　　}<br>　　}<br>　　this.length = 1;<br>};</p>
<p>var colors = [“red”, “blue”, “grey”];<br>colors.remove(1);<br>console.log(colors); // [“red”, “grey”]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vue的计算属性和侦听属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/11/Vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/" class="article-date">
  	<time datetime="2019-09-11T07:41:40.000Z" itemprop="datePublished">2019-09-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/11/Vue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/">
        Vue的计算属性和侦听属性
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1.计算属性（computed）</strong></p>
<div id="example">   
    <p>Original message: ""</p> 
    <p>Computed reversed message: ""</p>
</div>

<p>var vm = new Vue({<br>  el: ‘#example’,<br>  data: {<br>    message: ‘Hello’<br>  },<br>  computed: {<br>    // 计算属性的 getter<br>    reversedMessage: function () {<br>      // <code>this</code> 指向 vm 实例<br>      return this.message.split(‘’).reverse().join(‘’)<br>    }<br>  }<br>})</p>
<p>上面的运行结果为：</p>
<p>Original message: “Hello” </p>
<p>Computed reversed message: “olleH”</p>
<p>在上面的例子中，声明了一个计算属性reversedMessage。我们提供的函数将用作属性vm.reversedMessage的getter函数。</p>
<p>console.log(vm.reversedMessage) // =&gt; ‘olleH’ </p>
<p>vm.message = ‘Goodbye’ </p>
<p>console.log(vm.reversedMessage) // =&gt; ‘eybdooG’</p>
<p>这时候如果通过浏览器的控制台自行修改例子中的vm的话，vm.reversedMessage的值将会始终取决于vm.message的值。</p>
<p>我们可以像绑定普通的属性那样在模板中绑定计算属性。因为vue知道vm.reversedMessage是依赖于vm.message的，因此当vm.message的值发生改变的时候，所有依赖于vm.reversedMessage的绑定也会更新。而且最妙之处在于，我们已经以声明式的方式创建了这种依赖关系：计算属性的getter函数是没有副作用（side effect）的，因为它并不会改变被依赖的属性值。比如前面的vm.reversedMessage并不会改变vm.message的值（单向依赖），使得计算属性易于测试和理解。</p>
<p><strong>计算属性的getter</strong></p>
<p>计算属性默认只有getter，不过在需要的时候，也可以提供一个setter。</p>
<p>computed: {  </p>
<p>​    fullName: {    </p>
<p>​     // getter    </p>
<p>​    get: function () {      </p>
<p>​         return this.firstName + ‘ ‘ + this.lastName   </p>
<p>​    },   </p>
<p>​     //setter   </p>
<p>​    set: function (newValue) {     </p>
<p>​       var names = newValue.split(‘ ‘)     </p>
<p>​       this.firstName = names[0]      </p>
<p>​       this.lastName = names[names.length - 1]    </p>
<p>​     } </p>
<p>   } </p>
<p>}</p>
<p>这个时候，如果再浏览器控制台中运行vm.fullName = ‘xxx xxxx’的时候，setter函数就会被调用，vm.firstName和vm.lastName也会相应地被更新。</p>
<p><strong>侦听器（侦听属性）</strong></p>
<p>vue提供了一种更通用的方式来观察和响应vue实例上的数据变动。虽然计算属性在大多数的情况下更合适，但是有时候也需要一个自定义的侦听器（侦听属性）。当需要在数据变化的时候执行异步或开销较大的操作时，这个方式十分有用。</p>
<div id="watch-example">
  <p>
    Ask a yes/no question:
    <input v-model="question">
  </p>
  <p></p>
</div>

<!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 -->
<!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 -->

<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
<script>
var watchExampleVM = new Vue({
  el: '#watch-example',
  data: {
    question: '',
    answer: 'I cannot give you an answer until you ask a question!'
  },
  watch: {
    // 如果 `question` 发生改变，这个函数就会运行
    question: function (newQuestion, oldQuestion) {
      this.answer = 'Waiting for you to stop typing...'
      this.debouncedGetAnswer()
    }
  },
  created: function () {
    // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。
    // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率
    // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于
    // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，
    // 请参考：https://lodash.com/docs#debounce
    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
  },
  methods: {
    getAnswer: function () {
      if (this.question.indexOf('?') === -1) {
        this.answer = 'Questions usually contain a question mark. ;-)'
        return
      }
      this.answer = 'Thinking...'
      var vm = this
      axios.get('http://www.yanggb.com.cn/api')
        .then(function (response) {
          vm.answer = _.capitalize(response.data.answer)
        })
        .catch(function (error) {
          vm.answer = 'Error! Could not reach the API. ' + error
        })
    }
  }
})
</script>

<p>在这个示例中，使用watch选项允许我们执行异步操作 (访问一个API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<p><strong>侦听属性vs计算属性</strong></p>
<p>当你有一些数据需要随着其它数据变动而变动时候，你很容易会滥用watch侦听属性，而通常更好的做法则是使用计算属性而不是命令式的watch回调。</p>
<div id="demo"></div>

<p>var vm = new Vue({<br>  el: ‘#demo’,<br>  data: {<br>    firstName: ‘Foo’,<br>    lastName: ‘Bar’,<br>    fullName: ‘Foo Bar’<br>  },<br>  watch: {<br>    firstName: function (val) {<br>      this.fullName = val + ‘ ‘ + this.lastName<br>    },<br>    lastName: function (val) {<br>      this.fullName = this.firstName + ‘ ‘ + val<br>    }<br>  }<br>})</p>
<p>在上面的这段代码中，侦听了firstName和lastName两个属性，这两个属性如果发生了改变，则会触发侦听属性的回调函数，将两个属性值拼接到fullName属性中。这种方式是命令式的，且两个侦听属性功能重复。</p>
<p>var vm = new Vue({<br>  el: ‘#demo’,<br>  data: {<br>    firstName: ‘Foo’,<br>    lastName: ‘Bar’<br>  },<br>  computed: {<br>    fullName: function () {<br>      return this.firstName + ‘ ‘ + this.lastName<br>    }<br>  }<br>})</p>
<p>改成了声明式的计算属性之后，代码就显得简洁且清晰了很多。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-JavaScript中常用API整理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/15/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/" class="article-date">
  	<time datetime="2019-08-15T05:30:48.000Z" itemprop="datePublished">2019-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/15/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8API%E6%95%B4%E7%90%86/">
        JavaScript中常用API整理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一些JavaScript常用的API代码，有DOM操作、CSS操作、对象（Object对象、Array对象、Number对象、String对象、Math对象、JSON对象和Console对象）操作，整理出来方便以后使用。</p>
<p><strong>一、节点</strong></p>
<p><strong>1.1 节点属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeName   &#x2F;&#x2F;返回节点名称，只读</span><br><span class="line">Node.nodeType   &#x2F;&#x2F;返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue  &#x2F;&#x2F;返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent  &#x2F;&#x2F;返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI    &#x2F;&#x2F;返回当前网页的绝对路径</span><br><span class="line">Node.ownerDocument  &#x2F;&#x2F;返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling  &#x2F;&#x2F;返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling  &#x2F;&#x2F;返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode   &#x2F;&#x2F;返回当前节点的父节点</span><br><span class="line">Node.parentElement  &#x2F;&#x2F;返回当前节点的父Element节点</span><br><span class="line">Node.childNodes   &#x2F;&#x2F;返回当前节点的所有子节点</span><br><span class="line">Node.firstChild  &#x2F;&#x2F;返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild   &#x2F;&#x2F;返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;parentNode接口</span><br><span class="line">Node.children  &#x2F;&#x2F;返回指定节点的所有Element子节点</span><br><span class="line">Node.firstElementChild  &#x2F;&#x2F;返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild   &#x2F;&#x2F;返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount  &#x2F;&#x2F;返回当前节点所有Element子节点的数目。</span><br></pre></td></tr></table></figure>

<p><strong>1.2 操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node.appendChild(node)   &#x2F;&#x2F;向节点添加最后一个子节点</span><br><span class="line">Node.hasChildNodes()   &#x2F;&#x2F;返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true);  &#x2F;&#x2F; 默认为false(克隆节点), true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode)  &#x2F;&#x2F; 在指定子节点之前插入新的子节点</span><br><span class="line">Node.removeChild(node)   &#x2F;&#x2F;删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild)  &#x2F;&#x2F;替换节点</span><br><span class="line">Node.contains(node)  &#x2F;&#x2F;返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node)   &#x2F;&#x2F;返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe)  &#x2F;&#x2F;返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</span><br><span class="line">Node.normalize()   &#x2F;&#x2F;用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ChildNode接口</span><br><span class="line">Node.remove()  &#x2F;&#x2F;用于删除当前节点</span><br><span class="line">Node.before()  </span><br><span class="line">Node.after()</span><br><span class="line">Node.replaceWith()</span><br></pre></td></tr></table></figure>

<p><strong>1.3 Document节点</strong></p>
<p><strong>1.3.1 Document节点的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement  &#x2F;&#x2F;返回当前文档的根节点</span><br><span class="line">document.defaultView   &#x2F;&#x2F;返回document对象所在的window对象</span><br><span class="line">document.body   &#x2F;&#x2F;返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head   &#x2F;&#x2F;返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement  &#x2F;&#x2F;返回当前文档中获得焦点的那个元素。</span><br><span class="line">&#x2F;&#x2F;节点集合属性</span><br><span class="line">document.links  &#x2F;&#x2F;返回当前文档的所有a元素</span><br><span class="line">document.forms  &#x2F;&#x2F;返回页面中所有表单元素</span><br><span class="line">document.images  &#x2F;&#x2F;返回页面中所有图片元素</span><br><span class="line">document.embeds  &#x2F;&#x2F;返回网页中所有嵌入对象</span><br><span class="line">document.scripts  &#x2F;&#x2F;返回当前文档的所有脚本</span><br><span class="line">document.styleSheets  &#x2F;&#x2F;返回当前网页的所有样式表</span><br><span class="line">&#x2F;&#x2F;文档信息属性</span><br><span class="line">document.documentURI  &#x2F;&#x2F;表示当前文档的网址</span><br><span class="line">document.URL  &#x2F;&#x2F;返回当前文档的网址</span><br><span class="line">document.domain  &#x2F;&#x2F;返回当前文档的域名</span><br><span class="line">document.lastModified  &#x2F;&#x2F;返回当前文档最后修改的时间戳</span><br><span class="line">document.location  &#x2F;&#x2F;返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer  &#x2F;&#x2F;返回当前文档的访问来源</span><br><span class="line">document.title    &#x2F;&#x2F;返回当前文档的标题</span><br><span class="line">document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。</span><br><span class="line">document.readyState  &#x2F;&#x2F;返回当前文档的状态</span><br><span class="line">document.designMode  &#x2F;&#x2F;控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode  &#x2F;&#x2F;返回浏览器处理文档的模式</span><br><span class="line">document.cookie   &#x2F;&#x2F;用来操作Cookie</span><br></pre></td></tr></table></figure>

<p><strong>1.3.2 Document节点的方法</strong></p>
<p><strong>（1）读写方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.open()   &#x2F;&#x2F;用于新建并打开一个文档</span><br><span class="line">document.close()   &#x2F;&#x2F;不安比open方法所新建的文档</span><br><span class="line">document.write()   &#x2F;&#x2F;用于向当前文档写入内容</span><br><span class="line">document.writeIn()  &#x2F;&#x2F;用于向当前文档写入内容，尾部添加换行符。</span><br></pre></td></tr></table></figure>

<p><strong>（2）查找节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(selectors)   &#x2F;&#x2F;接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors)  &#x2F;&#x2F;接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName)  &#x2F;&#x2F;返回所有指定HTML标签的元素document.getElementsByClassName(className)   &#x2F;&#x2F;返回包括了所有class名字符合指定条件的元素document.getElementsByName(name)   &#x2F;&#x2F;用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）</span><br><span class="line">document.getElementById(id)   &#x2F;&#x2F;返回匹配指定id属性的元素节点。</span><br><span class="line">document.elementFromPoint(x,y)  &#x2F;&#x2F;返回位于页面指定位置最上层的Element子节点。</span><br></pre></td></tr></table></figure>

<p><strong>（3）生成节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.createElement(tagName)   &#x2F;&#x2F;用来生成HTML元素节点。</span><br><span class="line">document.createTextNode(text)   &#x2F;&#x2F;用来生成文本节点</span><br><span class="line">document.createAttribute(name)  &#x2F;&#x2F;生成一个新的属性对象节点，并返回它。document.createDocumentFragment()  &#x2F;&#x2F;生成一个DocumentFragment对象</span><br></pre></td></tr></table></figure>

<p><strong>（4）事件方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.createEvent(type)   &#x2F;&#x2F;生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture)  &#x2F;&#x2F;注册事件document.removeEventListener(type,listener,capture)  &#x2F;&#x2F;注销事件document.dispatchEvent(event)  &#x2F;&#x2F;触发事件</span><br></pre></td></tr></table></figure>

<p><strong>1.4 Element节点</strong></p>
<p><strong>1.4.1 Element节点的属性</strong></p>
<p><strong>（1）特性属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Element.attributes  &#x2F;&#x2F;返回当前元素节点的所有属性节点</span><br><span class="line">Element.id  &#x2F;&#x2F;返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName  &#x2F;&#x2F;返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML   &#x2F;&#x2F;返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML  &#x2F;&#x2F;返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className  &#x2F;&#x2F;返回当前元素的class属性，可读写</span><br><span class="line">Element.classList  &#x2F;&#x2F;返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset   &#x2F;&#x2F;返回元素节点中所有的data-*属性。</span><br></pre></td></tr></table></figure>

<p><strong>（2）尺寸属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Element.clientHeight   &#x2F;&#x2F;返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth   &#x2F;&#x2F;返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft   &#x2F;&#x2F;返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop   &#x2F;&#x2F;返回元素节点顶部边框的宽度</span><br><span class="line">Element.scrollHeight  &#x2F;&#x2F;返回元素节点的总高度</span><br><span class="line">Element.scrollWidth  &#x2F;&#x2F;返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft  &#x2F;&#x2F;返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置</span><br><span class="line">Element.scrollTop   &#x2F;&#x2F;返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line">Element.offsetHeight   &#x2F;&#x2F;返回元素的垂直高度(包含border,padding)</span><br><span class="line">Element.offsetWidth    &#x2F;&#x2F;返回元素的水平宽度(包含border,padding)</span><br><span class="line">Element.offsetLeft    &#x2F;&#x2F;返回当前元素左上角相对于</span><br><span class="line">Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop   &#x2F;&#x2F;返回水平位移</span><br><span class="line">Element.style  &#x2F;&#x2F;返回元素节点的行内样式</span><br></pre></td></tr></table></figure>

<p><strong>（3）节点相关属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Element.children   &#x2F;&#x2F;包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount   &#x2F;&#x2F;返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild  &#x2F;&#x2F;返回当前节点的第一个Element子节点  </span><br><span class="line">Element.lastElementChild   &#x2F;&#x2F;返回当前节点的最后一个Element子节点 </span><br><span class="line">Element.nextElementSibling  &#x2F;&#x2F;返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling  &#x2F;&#x2F;返回当前元素节点的前一个兄弟HTML节点</span><br><span class="line">Element.offsetParent   &#x2F;&#x2F;返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素</span><br></pre></td></tr></table></figure>

<p><strong>1.4.2 Element节点的方法</strong></p>
<p><strong>（1）位置方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getBoundingClientRect()  &#x2F;&#x2F; getBoundingClientRect返回一个对象，包含：top,left,right,bottom,width,height </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; top 元素上外边界距窗口最上面的距离</span><br><span class="line">&#x2F;&#x2F; right 元素右外边界距窗口最上面的距离</span><br><span class="line">&#x2F;&#x2F; bottom 元素下外边界距窗口最上面的距离</span><br><span class="line">&#x2F;&#x2F; left 元素左外边界距窗口最上面的距离</span><br><span class="line">&#x2F;&#x2F; width 元素自身宽(包含border,padding)</span><br><span class="line">&#x2F;&#x2F; height 元素自身高(包含border,padding) </span><br><span class="line"></span><br><span class="line">getClientRects()   &#x2F;&#x2F;返回当前元素在页面上形参的所有矩形</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 元素在页面上的偏移量  </span><br><span class="line">var rect &#x3D; el.getBoundingClientRect()  </span><br><span class="line">return &#123;    </span><br><span class="line">  top: rect.top + document.body.scrollTop,     </span><br><span class="line">  left: rect.left + document.body.scrollLeft  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）属性方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttribute()：读取指定属性 </span><br><span class="line">Element.setAttribute()：设置指定属性 </span><br><span class="line">Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  Element.removeAttribute()：移除指定属性</span><br></pre></td></tr></table></figure>

<p><strong>（3）查找方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element.querySelector()  </span><br><span class="line">Element.querySelectorAll()  </span><br><span class="line">Element.getElementsByTagName()  </span><br><span class="line">Element.getElementsByClassName()</span><br></pre></td></tr></table></figure>

<p><strong>（4）事件方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Element.addEventListener()：添加事件的回调函数  </span><br><span class="line">Element.removeEventListener()：移除事件监听函数  </span><br><span class="line">Element.dispatchEvent()：触发事件</span><br><span class="line">&#x2F;&#x2F;ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line">&#x2F;&#x2F; event对象 </span><br><span class="line">var event &#x3D; window.event||event;    </span><br><span class="line">&#x2F;&#x2F; 事件的目标节点  </span><br><span class="line">var target &#x3D; event.target || event.srcElement;</span><br><span class="line">&#x2F;&#x2F; 事件代理  </span><br><span class="line">ul.addEventListener(&#39;click&#39;, function(event) &#123;    </span><br><span class="line">    if (event.target.tagName.toLowerCase() &#x3D;&#x3D;&#x3D; &#39;li&#39;) &#123;   </span><br><span class="line">           console.log(event.target.innerHTML)    </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>二、CSS操作</strong></p>
<p><strong>（1）类名操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ie8以下</span><br><span class="line">Element.className  &#x2F;&#x2F;获取元素节点的类名</span><br><span class="line">Element.className +&#x3D; &#39; &#39; + newClassName  &#x2F;&#x2F;新增一个类名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;  </span><br><span class="line">     return new RegExp(className,&#39;gi&#39;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除class</span><br><span class="line">function removeClass(element,className)&#123;  </span><br><span class="line">   element.className &#x3D; element.className.replace(new RegExp(&#39;(^|\\b)&#39; + className.split(&#39; &#39;).join(&#39;|&#39;) + &#39;(\\b|$)&#39;, &#39;gi&#39;),&#39;&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;ie10 </span><br><span class="line">element.classList.add(className)  &#x2F;&#x2F;新增</span><br><span class="line">element.classList.remove(className)  &#x2F;&#x2F;删除</span><br><span class="line">element.classList.contains(className)  &#x2F;&#x2F;是否包含</span><br><span class="line">element.classList.toggle(className)  &#x2F;&#x2F;toggle class</span><br></pre></td></tr></table></figure>

<p><strong>（2）style操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(&#39;style&#39;,&#39;&#39;)</span><br><span class="line">element.style.backgroundColor &#x3D; &#39;red&#39;</span><br><span class="line">element.style.cssText &#x2F;&#x2F;用来读写或删除整个style属性</span><br><span class="line">element.style.setProperty(propertyName,value)  &#x2F;&#x2F;设置css属性element.style.getPropertyValue(property)  &#x2F;&#x2F;获取css属性element.style.removeProperty(property)  &#x2F;&#x2F;删除css属性操作非内联样式</span><br><span class="line">&#x2F;&#x2F;ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">&#x2F;&#x2F;ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">&#x2F;&#x2F;伪类</span><br><span class="line">window.getComputedStyle(el,&#39;:after&#39;)[attrName]</span><br></pre></td></tr></table></figure>

<p><strong>三、对象</strong></p>
<p><strong>3.1 Object对象</strong></p>
<p><strong>（1）生成实例对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; new Object()</span><br></pre></td></tr></table></figure>

<p><strong>（2）属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype   &#x2F;&#x2F;返回原型对象</span><br></pre></td></tr></table></figure>

<p><strong>（3）方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(o)   &#x2F;&#x2F;遍历对象的可枚举属性</span><br><span class="line">Object.getOwnPropertyName(o)   &#x2F;&#x2F;遍历对象不可枚举的属性</span><br></pre></td></tr></table></figure>

<p>对象实例的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">valueOf()：返回当前对象对应的值。</span><br><span class="line">toString()：返回当前对象对应的字符串形式。</span><br><span class="line">toLocaleString()：返回当前对象对应的本地字符串形式。</span><br><span class="line">hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</span><br><span class="line">isPrototypeOf()：判断当前对象是否为另一个对象的原型。</span><br><span class="line">propertyIsEnumerable()：判断某个属性是否可枚举。</span><br></pre></td></tr></table></figure>

<p><strong>3.2 Array对象</strong></p>
<p><strong>（1）生成实例对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new Array()</span><br></pre></td></tr></table></figure>

<p><strong>（2）属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.length  &#x2F;&#x2F;长度</span><br></pre></td></tr></table></figure>

<p><strong>（3）Array.isArray()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(a)   &#x2F;&#x2F;用来判断一个值是否为数组</span><br></pre></td></tr></table></figure>

<p><strong>（4）Array实例的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a.valueof()   &#x2F;&#x2F;返回数组本身</span><br><span class="line">a.toString()  &#x2F;&#x2F;返回数组的字符串形式</span><br><span class="line">a.push(value,vlaue....)   &#x2F;&#x2F;用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</span><br><span class="line">pop()   &#x2F;&#x2F;用于删除数组的最后一个元素，并返回该元素</span><br><span class="line">join()  &#x2F;&#x2F;以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</span><br><span class="line">concat()  &#x2F;&#x2F;用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift()  &#x2F;&#x2F;用于删除数组的第一个元素，并返回该元素。</span><br><span class="line">unshift(value)  &#x2F;&#x2F;用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</span><br><span class="line">reverse()   &#x2F;&#x2F;用于颠倒数组中元素的顺序，返回改变后的数组</span><br><span class="line">slice(start_index, upto_index);   &#x2F;&#x2F;用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。</span><br><span class="line">splice(index, count_to_remove, addElement1, addElement2, ...);   </span><br><span class="line">&#x2F;&#x2F;用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</span><br><span class="line">sort()   &#x2F;&#x2F;对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map()   &#x2F;&#x2F;对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</span><br><span class="line">map(elem,index,arr)   &#x2F;&#x2F;map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</span><br><span class="line">forEach()   &#x2F;&#x2F;遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。</span><br><span class="line">filter()   &#x2F;&#x2F;参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</span><br><span class="line">some()    &#x2F;&#x2F;用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。</span><br><span class="line">every()   &#x2F;&#x2F;用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。</span><br><span class="line">reduce()   &#x2F;&#x2F;依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight()  &#x2F;&#x2F;依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s)   &#x2F;&#x2F;返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置</span><br><span class="line">lastIndexOf()  &#x2F;&#x2F;返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span><br></pre></td></tr></table></figure>

<p><strong>3.3 Number对象</strong></p>
<p><strong>（1）生成对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; new Number()</span><br></pre></td></tr></table></figure>

<p><strong>（2）Number对象的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number.POSITIVE_INFINITY：正的无限，指向Infinity。</span><br><span class="line">Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。</span><br><span class="line">Number.NaN：表示非数值，指向NaN。</span><br><span class="line">Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。</span><br><span class="line">Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。</span><br><span class="line">Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</span><br></pre></td></tr></table></figure>

<p><strong>（4）Number对象实例的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toString()   &#x2F;&#x2F;用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</span><br><span class="line">toFixed()   &#x2F;&#x2F;用于将一个数转为指定位数的小数，返回这个小数对应的字符串。</span><br><span class="line">toExponential()  &#x2F;&#x2F;用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。</span><br><span class="line">toPrecision()  &#x2F;&#x2F;用于将一个数转为指定位数的有效数字。</span><br></pre></td></tr></table></figure>

<p><strong>3.4 String 对象</strong></p>
<p><strong>（1）生成实例对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; new String()</span><br></pre></td></tr></table></figure>

<p><strong>（2）String对象的属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.length   &#x2F;&#x2F;返回字符串的长度</span><br></pre></td></tr></table></figure>

<p><strong>（3）方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s.chatAt(index)   &#x2F;&#x2F;返回指定位置的字符</span><br><span class="line">s.fromCharCode()    &#x2F;&#x2F;该方法的参数是一系列Unicode码点，返回对应的字符串。</span><br><span class="line">s.charCodeAt(index)    &#x2F;&#x2F;返回给定位置字符的Unicode码点（十进制表示）</span><br><span class="line">s.concat(s2)  &#x2F;&#x2F;用于连接两个字符串</span><br><span class="line">s.slice(start,end)   &#x2F;&#x2F;用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span><br><span class="line">s.substring(start,end)  &#x2F;&#x2F;用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。</span><br><span class="line">s.substr(start,length)   &#x2F;&#x2F;用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span><br><span class="line">s.indexOf(s)   &#x2F;&#x2F;返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 </span><br><span class="line">s.lastIndexOf()  &#x2F;&#x2F;返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">s.trim()  &#x2F;&#x2F;用于去除字符串两端的空格，返回一个新字符串</span><br><span class="line">s.toLowerCase()  &#x2F;&#x2F;用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。</span><br><span class="line">s.toUpperCase()  &#x2F;&#x2F;全部转为大写</span><br><span class="line">s.localeCompare(s2)  &#x2F;&#x2F;用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</span><br><span class="line">s.match(regexp)   &#x2F;&#x2F;用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</span><br><span class="line">s.search()  &#x2F;&#x2F;返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</span><br><span class="line">s.replace(oldValue,newValue)  &#x2F;&#x2F;用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</span><br><span class="line">s.split()  &#x2F;&#x2F;按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。</span><br></pre></td></tr></table></figure>

<p><strong>3.5 Math对象</strong></p>
<p><strong>（1）属性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Math.E：常数e。</span><br><span class="line">Math.LN2：2的自然对数。</span><br><span class="line">Math.LN10：10的自然对数。</span><br><span class="line">Math.LOG2E：以2为底的e的对数。</span><br><span class="line">Math.LOG10E：以10为底的e的对数。</span><br><span class="line">Math.PI：常数Pi。</span><br><span class="line">Math.SQRT1_2：0.5的平方根。</span><br><span class="line">Math.SQRT2：2的平方根。</span><br></pre></td></tr></table></figure>

<p><strong>（2）数学方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Math.abs()：返回参数的绝对值  </span><br><span class="line">Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。</span><br><span class="line">Math.floor()：向下取整 </span><br><span class="line">Math.max(n,n1,...)：可接受多个参数，返回最大值  </span><br><span class="line">Math.min(n,n1,..)：可接受多个参数，返回最小值  </span><br><span class="line">Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。</span><br><span class="line">Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。</span><br><span class="line">Math.log()：返回以e为底的自然对数值。</span><br><span class="line">Math.exp()：返回e的指数，也就是常数e的参数次方。</span><br><span class="line">Math.round()：四舍五入  </span><br><span class="line">Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</span><br></pre></td></tr></table></figure>

<p><strong>（3）三角函数方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.sin()：返回参数的正弦  </span><br><span class="line">Math.cos()：返回参数的余弦  </span><br><span class="line">Math.tan()：返回参数的正切 </span><br><span class="line">Math.asin()：返回参数的反正弦（弧度值）  </span><br><span class="line">Math.acos()：返回参数的反余弦（弧度值）  </span><br><span class="line">Math.atan()：返回参数的反正切（弧度值）</span><br></pre></td></tr></table></figure>

<p><strong>3.6 JSON对象</strong></p>
<p><strong>（1）方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify()   </span><br><span class="line">&#x2F;&#x2F;用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。&#x2F;&#x2F;还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</span><br><span class="line"></span><br><span class="line">JSON.parse()   &#x2F;&#x2F;用于将JSON字符串转化成对象。</span><br></pre></td></tr></table></figure>




      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Vue的组件通信方式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/18/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" class="article-date">
  	<time datetime="2019-05-18T11:54:00.000Z" itemprop="datePublished">2019-05-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/18/Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/">
        Vue的组件通信方式
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em>vue组件传值几种方式</em></strong></p>
<p><em>1.父组件通过prop向子组件传值</em></p>
<p><em>2.子组件通过this.$emit()触发父组组件传递过来的方法向父组件传值</em></p>
<p><em>3.兄弟组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用vuex</em></p>
<p><em>4.中央事件总线：</em></p>
<p>//Bus.$emit 发送消息</p>
<p>Bus.$emit(‘inceptMessage’, this.msg)</p>
<p>//Bus.$on  接收消息</p>
<p>Bus.$on(‘inceptMessage’,(msg) =&gt; {</p>
<p>​    this.fromComponentAMsg = msg</p>
<p>})</p>
<p><strong><em>下面着重介绍一下父子之间的通信方式：</em></strong></p>
<p><strong>一、父组件向子组件传递数据：</strong></p>
<ol>
<li>1 父组件中使用子组件的时候通过 v-bind 向子组件传递数据</li>
</ol>
<!-- 动态赋予一个变量的值 -->

<p><blog-post v-bind:title="post.title"></blog-post></p>
<p>1.2 子组件中声明props来接收父组件传递过来的数据：</p>
<p>export default {</p>
<p> props : [“title”]</p>
<p>}</p>
<p>//或者</p>
<p>export default {</p>
<p> props : {</p>
<pre><code> title:&#123;

  type:string,</code></pre>
<p>​    default:””</p>
<p>  }</p>
<p> }</p>
<p>}</p>
<p><strong>二、子组件向父组件传递数据：</strong></p>
<p>主要步骤：</p>
<p>1、在父组件创建子组件实例的时候，通过v-on给子组件传递一个自定义事件。</p>
<p>2、在子组件 中 通过’$emit’触发 当前实例上的 自定义事件。</p>
<p>父组件中：</p>
<template>
    <div class="fatherPageWrap">
          <h1>这是父组件</h1>
          <!-- 引入子组件，v-on监听自定义事件 -->
          <emitChild v-on:emitMethods="fatherMethod"></emitChild>
    </div>
</template>

<script type="text/javascript">
    import emitChild from '@/page/children/emitChild.vue';
    export default{
        data () {
            return {}
        },
        components : {
            emitChild
        },
        methods : {
            fatherMethod(params){
                 alert(JSON.stringify(params));
            }
        }
    }
</script>

<p>子组件中：</p>
<template>
    <div class="childPageWrap">
         <h1>这是子组件</h1>
    </div>
</template>

<script type="text/javascript">
    export default{
        data () {
           return {}
        },
        mounted () {
           //通过 emit 触发
           this.$emit('emitMethods',{"name" : 123});
        }
    }
</script>


<p>结果：子组件会调用父组件的fatherMethod 方法，并且会alert 传递过去的参数：{“name”:123}</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Javascript中常用的代码片段总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/13/Javascript%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%80%BB%E7%BB%93/" class="article-date">
  	<time datetime="2019-04-13T10:29:05.000Z" itemprop="datePublished">2019-04-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/Javascript%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%80%BB%E7%BB%93/">
        Javascript中常用的代码片段总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、预加载图像**</p>
<p>如果你的网页中需要使用大量初始不可见的（例如，悬停的）图像，那么可以预加载这些图像。</p>
<p> $.preloadImages = function(){</p>
<p>​     for(var i=0; i&lt;arguments.length; i++){</p>
<p>​      $(‘<img>‘).attr(‘src’, arguments[i])</p>
<p>​      }</p>
<p>}</p>
<p>$.preloadImages(‘img/hover-on.png’,’img/hover-off.png’)</p>
<p><strong>二、检查图像是否加载</strong></p>
<p>有时为了继续脚本，你可能需要检查图像是否全部加载完毕。</p>
<p>​     $(‘img’).load(function(){</p>
<p>​       console.log(‘image load successful’)</p>
<p>​    })</p>
<p>也可以使用 ID 或 CLASS 替换<img> 标签来检查某个特定的图像是否被加载。</p>
<p><strong>三、自动修复破坏的图像</strong></p>
<p>  $(‘img’).on(‘error’,function(){</p>
<p>​     if(! $(this).hasClass(‘broken-image’)){</p>
<p>​           $(this).prop(‘src’,’img/broken.png’).addClass(‘broken-image’)</p>
<p>​       }</p>
<p>​    })</p>
<p><strong>四、悬停切换</strong></p>
<p>当用户鼠标悬停在可点击的元素上时，可添加类到元素中，反之则移除类。</p>
<p>$(selector).hover(function(){</p>
<p>​    $(this).addClass(‘hover’)</p>
<p>},function(){</p>
<p>   $(this).removeClass(‘hover’)</p>
<p>})</p>
<p>只需要添加必要的 CSS 即可。更简单的方法是使用 toggleClass() 方法。</p>
<p>$(selector).hover(function(){</p>
<p>​    $(this).toggleClass(‘hover’)</p>
<p>})</p>
<p><strong>五、淡入淡出/显示隐藏</strong></p>
<p>//Fade</p>
<p>$(‘.btn’).click(function(){</p>
<p>   $(‘.element’).fadeToggle(‘slow’)</p>
<p>});</p>
<p>//Toggle</p>
<p>$(‘.btn’).click(function(){</p>
<p>   $(‘.element’).slideToggle(‘slow’)</p>
<p>});</p>
<p><strong>六、鼠标滚轮</strong></p>
<p>$(‘#content’).on(“mousewheel DOMMouseScroll”, <strong>function</strong> (event) {</p>
<p>  <em>// chrome &amp; ie || // firefox</em></p>
<p>  <strong>var</strong> delta = (event.originalEvent.wheelDelta &amp;&amp; (event.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) ||</p>
<p>​    (event.originalEvent.detail &amp;&amp; (event.originalEvent.detail &gt; 0 ? -1 : 1)); </p>
<p>  <strong>if</strong> (delta &gt; 0) {</p>
<p>​    console.log(‘mousewheel top’);</p>
<p>  } <strong>else</strong> <strong>if</strong> (delta &lt; 0) {</p>
<p>​    console.log(‘mousewheel bottom’);</p>
<p>  }</p>
<p>});</p>
<p><strong>七、鼠标坐标</strong></p>
<p>1、JavaScript实现</p>
<p>X:<input id="xxx" type="text"/></p>
<p>Y:<input id="yyy" type="text"/></p>
<p><strong>function</strong> mousePosition(ev){</p>
<p>  <strong>if</strong> (ev.pageX || ev.pageY){</p>
<p>​    <strong>return</strong> {x:ev.pageX, y:ev.pageY};</p>
<p>  }</p>
<p>  <strong>return</strong> {</p>
<p>​    x:ev.clientX + document.body.scrollLeft - document.body.clientLeft,</p>
<p>​    y:ev.clientY + document.body.scrollTop - document.body.clientTop</p>
<p>  };</p>
<p>}</p>
<p><strong>function</strong> mouseMove(ev){</p>
<p>  ev = ev || window.event;</p>
<p>  <strong>var</strong> mousePos = mousePosition(ev);</p>
<p>  document.getElementById(‘xxx’).value = mousePos.x;</p>
<p>  document.getElementById(‘yyy’).value = mousePos.y;</p>
<p>}</p>
<p>document.onmousemove = mouseMove;</p>
<p>2、jQuery实现</p>
<p>$(‘#ele’).click(<strong>function</strong>(event){</p>
<p>  <em>//获取鼠标在图片上的坐标</em></p>
<p>  console.log(‘X：’ + event.offsetX+’ Y:’ + event.offsetY);</p>
<p>  <em>//获取元素相对于页面的坐标</em></p>
<p>  console.log(‘X：’+$(<strong>this</strong>).offset().left+’ Y:’+$(<strong>this</strong>).offset().top);</p>
<p>});</p>
<p><strong>八、禁止移动端浏览器页面滚动</strong></p>
<p>1、HTML实现</p>
<body ontouchmove="event.preventDefault()" >

<p>2、JavaScript实现</p>
<p>document.addEventListener(‘touchmove’, <strong>function</strong>(event) {</p>
<p>  event.preventDefault();</p>
<p>});</p>
<p><strong>九、阻止默认行为</strong></p>
<p><em>// JavaScript</em></p>
<p>document.getElementById(‘btn’).addEventListener(‘click’, <strong>function</strong> (event) {</p>
<p>  event = event || window.event；</p>
<p>  <strong>if</strong> (event.preventDefault){</p>
<p>​    <em>// W3C</em></p>
<p>​    event.preventDefault();</p>
<p>  } <strong>else</strong>{</p>
<p>​    <em>// IE</em></p>
<p>​    event.returnValue = <strong>false</strong>;</p>
<p>  }</p>
<p>}, <strong>false</strong>);</p>
<p><em>// jQuery</em></p>
<p>$(‘#btn’).on(‘click’, <strong>function</strong> (event) {</p>
<p>  event.preventDefault();</p>
<p>});</p>
<p><strong>十、阻止冒泡</strong></p>
<p><em>// JavaScript</em></p>
<p>document.getElementById(‘btn’).addEventListener(‘click’, <strong>function</strong> (event) {</p>
<p>  event = event || window.event；</p>
<p>  <strong>if</strong> (event.stopPropagation){</p>
<p>​    <em>// W3C</em></p>
<p>​    event.stopPropagation();</p>
<p>  } <strong>else</strong>{</p>
<p>​    <em>// IE</em></p>
<p>​    event.cancelBubble = <strong>true</strong>;</p>
<p>  }</p>
<p>}, <strong>false</strong>);</p>
<p><em>// jQuery</em></p>
<p>$(‘#btn’).on(‘click’, <strong>function</strong> (event) {</p>
<p>  event.stopPropagation();</p>
<p>});</p>
<p><strong>十一、检测浏览器是否支持svg</strong></p>
<p><strong>function</strong> isSupportSVG() {</p>
<p>  <strong>var</strong> SVG_NS = ‘<a target="_blank" rel="noopener" href="http://www.w3.org/2000/svg&#39;">http://www.w3.org/2000/svg&#39;</a>;</p>
<p>  <strong>return</strong> !!document.createElementNS &amp;&amp;!!document.createElementNS(SVG_NS,’svg’).createSVGRect;</p>
<p>}</p>
<p>console.log(isSupportSVG());</p>
<p><strong>十二、检测浏览器是否支持canvas</strong></p>
<p><strong>function</strong> isSupportCanvas() {</p>
<p>  <strong>if</strong>(document.createElement(‘canvas’).getContext){</p>
<p>​    <strong>return</strong> <strong>true</strong>;</p>
<p>  }<strong>else</strong>{</p>
<p>​    <strong>return</strong> <strong>false</strong>;</p>
<p>  }</p>
<p>}</p>
<p>console.log(isSupportCanvas());</p>
<p><strong>十三、检测是否是微信浏览器</strong></p>
<p><strong>function</strong> isWeiXinClient() {</p>
<p>  <strong>var</strong> ua = navigator.userAgent.toLowerCase();</p>
<p>  <strong>if</strong> (ua.match(/MicroMessenger/i)==”micromessenger”) {</p>
<p>​    <strong>return</strong> <strong>true</strong>;</p>
<p>  } <strong>else</strong> {</p>
<p>​    <strong>return</strong> <strong>false</strong>;</p>
<p>  }</p>
<p>}</p>
<p>alert(isWeiXinClient());</p>
<p><strong>十四、强制移动端页面横屏显示</strong></p>
<p>$( window ).on( “orientationchange”, <strong>function</strong>( event ) {</p>
<p>  <strong>if</strong> (event.orientation==’portrait’) {</p>
<p>​    $(‘body’).css(‘transform’, ‘rotate(90deg)’);</p>
<p>  } <strong>else</strong> {</p>
<p>​    $(‘body’).css(‘transform’, ‘rotate(0deg)’);</p>
<p>  }</p>
<p>});</p>
<p>$( window ).orientationchange();</p>
<p><strong>十五、获得/失去焦点</strong></p>
<p>1、JavaScript实现</p>
<input id="ii" type="text" value="会员卡号/手机号"/>

<p><em>// JavaScript</em></p>
<p>window.onload = <strong>function</strong>(){</p>
<p>  <strong>var</strong> oIpt = document.getElementById(“i_input”);</p>
<p>  <strong>if</strong>(oIpt.value == “会员卡号/手机号”){</p>
<p>​    oIpt.style.color = “#888”;</p>
<p>  }<strong>else</strong>{</p>
<p>​    oIpt.style.color = “#000”;</p>
<p>  };</p>
<p>  oIpt.onfocus = <strong>function</strong>(){</p>
<p>​    <strong>if</strong>(<strong>this</strong>.value == “会员卡号/手机号”){</p>
<p>​      <strong>this</strong>.value=””;</p>
<p>​      <strong>this</strong>.style.color = “#000”;</p>
<p>​      <strong>this</strong>.type = “password”;</p>
<p>​    }<strong>else</strong>{</p>
<p>​      <strong>this</strong>.style.color = “#000”;</p>
<p>​    }</p>
<p>  };</p>
<p>oIpt.onblur = <strong>function</strong>(){</p>
<p>​    <strong>if</strong>(<strong>this</strong>.value == “”){</p>
<p>​      <strong>this</strong>.value=”会员卡号/手机号”;</p>
<p>​      <strong>this</strong>.style.color = “#888”;</p>
<p>​      <strong>this</strong>.type = “text”;</p>
<p>​    }</p>
<p>  };</p>
<p>}</p>
<p>2、jQuery实现</p>
<input type="text" class="oldpsw" id="showPwd" value="请输入您的注册密码"/>

<input type="password" name="psw" class="oldpsw" id="password" value="" style="display:none;"/>

<p><em>// jQuery</em></p>
<p>$(“#showPwd”).focus(<strong>function</strong>() {</p>
<p>  <strong>var</strong> text_value=$(<strong>this</strong>).val();</p>
<p>  <strong>if</strong> (text_value ==’请输入您的注册密码’) {</p>
<p>​    $(“#showPwd”).hide();</p>
<p>​    $(“#password”).show().focus();</p>
<p>  }</p>
<p>});</p>
<p>$(“#password”).blur(<strong>function</strong>() {</p>
<p>  <strong>var</strong> text_value = $(<strong>this</strong>).val();</p>
<p>  <strong>if</strong> (text_value == “”) {</p>
<p>​    $(“#showPwd”).show();</p>
<p>​    $(“#password”).hide();</p>
<p>  }</p>
<p>});</p>
<p><strong>十六、当前日期</strong></p>
<p><strong>var</strong> calculateDate = <strong>function</strong>(){</p>
<p>  <strong>var</strong> date = <strong>new</strong> Date();</p>
<p>  <strong>var</strong> weeks = [“日”,”一”,”二”,”三”,”四”,”五”,”六”];</p>
<p>  <strong>return</strong> date.getFullYear()+”年”+(date.getMonth()+1)+”月”+</p>
<p>  date.getDate()+”日 星期”+weeks[date.getDay()];</p>
<p>}</p>
<p>$(<strong>function</strong>(){</p>
<p>  $(“#dateSpan”).html(calculateDate());</p>
<p>});</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-javascript中this的指向问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/03/20/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/" class="article-date">
  	<time datetime="2019-03-20T02:46:01.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/">
        JavaScript中this的指向问题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别。</p>
<p><strong>一、在全局环境中</strong></p>
<p>在全局执行环境中（在任何函数体外部,this都是指向全局对象。在浏览器中，window对象即是全局对象)</p>
<p>console.log(this);               //Window </p>
<p>var a = 1;</p>
<p>console.log(window.a);       //1 </p>
<p>this.b = 3; </p>
<p>console.log(b);                   // 3 </p>
<p>console.log(window.b);     //3</p>
<p><strong>二、在函数环境中</strong></p>
<p> 在函数内容，this指向取决于函数调用的方式：</p>
<p>function f(){</p>
<p> “use strict”;                       //使用严格模式</p>
<p> console.log(this); } f();        // window ；使用严格模式时，输出undefined</p>
<p>实际调用函数的是浏览器的window.f();实际并非如果，在严格模式下，返回值：false，因为<code>f</code>是被直接调用的，而不是作为对象的属性或方法调用的（如 <code>window.f()</code>）。浏览器可能在支持严格模式时没有正确实现这个功能，于是它们错误地返回了<code>window</code>对象。</p>
<p><strong><em>this指向如何发生改变？</em></strong></p>
<p><strong>1、call和apply方法：</strong></p>
<p>将一个对象作为call或者apply的第一个参数，this将会被绑定到这个参数对象上。</p>
<p>var obj = {parent:’男’}; </p>
<p>var parent = ‘28’; </p>
<p>function child(obj){ </p>
<p>​     console.log(this.parent); </p>
<p>} </p>
<p>child(); // 28  </p>
<p> child.call(obj); //男 </p>
<p>child.apply(obj); //男</p>
<p>**2、bind方法: **</p>
<p>调用<code>f.bind(someObject)</code>会创建一个与<code>f</code>具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code>将永久地被绑定到了<code>bind</code>的第一个参数，不管函数是怎样调用的。</p>
<p>function f(){ </p>
<p> return this.a;</p>
<p> } </p>
<p>var g = f.bind({a:”js”}); </p>
<p>console.log(g()); // js</p>
<p> var h = g.bind({a:’html’});    // this已经被绑定bind的第一个参数，不会重复绑定，输出的值还是js console.log(h());      // js </p>
<p>var o = {a:css, f:f, g:g, h:h}; </p>
<p>console.log(o.f(), o.g(), o.h());      // css, js, js</p>
<p><strong>3、箭头函数</strong></p>
<p>箭头函数引入的其中一个原因，就是其不绑定this；在箭头函数中，箭头函数的<code>this</code>被设置为封闭的词法环境的，换句话说，箭头函数中的this取决于该函数被创建时的环境。</p>
<p>var objProject = this;</p>
<p> var foo = (() =&gt; this); </p>
<p>console.log(foo());  // window</p>
<p> console.log(objProject);  // window </p>
<p>console.log(foo() === objProject ); // true </p>
<p>// 作为对象的一个方法调用</p>
<p> var obj = {foo: foo}; </p>
<p>console.log(obj.foo() === objProject ); // true </p>
<p>// 尝试使用call来设定this </p>
<p>console.log(foo.call(obj) === objProject ); // true</p>
<p> // 尝试使用bind来设定</p>
<p>this foo = foo.bind(obj); </p>
<p>console.log(foo() === objProject ); // true</p>
<p><strong>4、作为对象的方法调用时</strong></p>
<p>当函数作为对象的方法被调用时，this指向调用的该函数的对象：</p>
<p>var obj = { </p>
<p> a: 37,  </p>
<p> fn: function() {  </p>
<p>​     return this.a;  </p>
<p>   } </p>
<p>}; </p>
<p>console.log(obj.fn());  // 37</p>
<p>对于在对象原型链上某处定义的方法，this指向的是调用这个方法的对象，就像该方法在对象上一样</p>
<p>var o = { </p>
<p>   f: function() {     </p>
<p>​       return this.a + this.b;   </p>
<p>​    }</p>
<p> }; </p>
<p>var p = Object.create(o); </p>
<p>p.a = 1; p.b = 4;</p>
<p> console.log(p.f());     // 5</p>
<p>在这个例子中，对象<code>p</code>没有属于它自己的<code>f</code>属性，它的f属性继承自它的原型。虽然在对 <code>f</code> 的查找过程中，最终是在 <code>o</code> 中找到 <code>f</code> 属性的，这并没有关系；查找过程首先从 <code>p.f</code> 的引用开始，所以函数中的 <code>this</code> 指向<code>p</code>。也就是说，因为<code>f</code>是作为<code>p</code>的方法调用的，所以它的<code>this</code>指向了<code>p</code>。</p>
<p><strong>5、作为构造函数</strong></p>
<p>当一个函数用作构造函数时（使用new关键字），它的<code>this</code>被绑定到正在构造的新对象。</p>
<p>虽然构造器返回的默认值是<code>this</code>所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回<code>this</code>对象）。</p>
<p>function C(){ </p>
<p>​    this.a = 37; </p>
<p>} </p>
<p>var o = new C();</p>
<p> console.log(o.a); //  37</p>
<p> function C2(){  </p>
<p>​      this.a = 37;  </p>
<p>​      return {a:38};</p>
<p> } </p>
<p>o = new C2(); </p>
<p>console.log(o.a); //  38，手动设置了返回对象</p>
<p><strong>6、作为DOM事件处理函数</strong></p>
<p>当函数被用作事件处理函数时，它的<code>this</code>指向触发事件的元素（一些浏览器在使用非<code>addEventListener</code>的函数动态添加监听函数时不遵守这个约定）。</p>
<p>// 被调用时，将关联的元素变成蓝色 </p>
<p>function bluify (e) {  </p>
<p>console.log(this === e.currentTarget); // 总是 true  </p>
<p>// 当 currentTarget 和 target 是同一个对象时为 true </p>
<p> console.log(this === e.target);          </p>
<p>this.style.backgroundColor = ‘#A5D9F3’; } </p>
<p>// 获取文档中的所有元素的列表 </p>
<p>var elements = document.getElementsByTagName(‘*’); </p>
<p>// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色 </p>
<p>for(var i=0 ; i&lt;elements.length ; i++) {  </p>
<p>elements[i].addEventListener(‘click’, bluify, false); </p>
<p>}</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 John Doe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>